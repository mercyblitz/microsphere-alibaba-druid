/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.microsphere.druid.filter;

import com.alibaba.druid.filter.Filter;
import com.alibaba.druid.filter.FilterAdapter;
import com.alibaba.druid.filter.FilterChain;
import com.alibaba.druid.pool.DruidDataSource;
import com.alibaba.druid.proxy.jdbc.DataSourceProxy;
import com.alibaba.druid.proxy.jdbc.PreparedStatementProxy;
import com.alibaba.druid.proxy.jdbc.ResultSetProxy;
import com.alibaba.druid.proxy.jdbc.StatementProxy;
import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.statement.SQLDeleteStatement;
import com.alibaba.druid.sql.ast.statement.SQLExprTableSource;
import com.alibaba.druid.sql.ast.statement.SQLInsertStatement;
import com.alibaba.druid.sql.ast.statement.SQLSelect;
import com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock;
import com.alibaba.druid.sql.ast.statement.SQLSelectStatement;
import com.alibaba.druid.sql.ast.statement.SQLTableSource;
import com.alibaba.druid.sql.ast.statement.SQLUpdateStatement;
import io.microsphere.lang.function.ThrowableSupplier;
import io.microsphere.logging.Logger;

import java.sql.SQLException;
import java.util.List;
import java.util.Objects;

import static com.alibaba.druid.sql.SQLUtils.parseStatements;
import static io.microsphere.logging.LoggerFactory.getLogger;
import static io.microsphere.util.ExceptionUtils.wrap;

/**
 * Abstract template class of Druid's {@link Filter} intercepts {@link StatementProxy}.
 * <p>
 * The implementation class has two scenarios mainly:
 * <ul>
 *     <li>One-Time Operations : {@link #execute(StatementProxy, ThrowableSupplier)} should be overridden.
 *     </li>
 *     <li>Two-Phase Operations : {@link #beforeExecute(StatementProxy, String)} and
 *     {@link #afterExecute(StatementProxy, String, Object, Throwable)} should be overridden.
 *     </li>
 * </ul>
 *
 * @author <a href="mailto:mercyblitz@gmail.com">Mercy<a/>
 * @see Filter
 * @see FilterAdapter
 * @see StatementProxy
 * @since 1.0.0
 */
public abstract class AbstractStatementFilter extends FilterAdapter {

    protected final Logger logger = getLogger(getClass());

    protected DataSourceProxy dataSource;

    protected String validationSQL;

    @Override
    public final void init(DataSourceProxy dataSource) {
        this.dataSource = dataSource;
        if (dataSource instanceof DruidDataSource) {
            DruidDataSource druidDataSource = (DruidDataSource) dataSource;
            this.validationSQL = druidDataSource.getValidationQuery();
        }
        if (logger.isTraceEnabled()) {
            logger.trace("DataSourceProxy({}) was initialized with validation SQL : {}", this.dataSource, this.validationSQL);
        }
    }

    @Override
    public final boolean preparedStatement_execute(FilterChain chain, PreparedStatementProxy statement) throws SQLException {
        return execute(statement, () -> super.preparedStatement_execute(chain, statement));
    }

    @Override
    public final ResultSetProxy preparedStatement_executeQuery(FilterChain chain, PreparedStatementProxy statement) throws SQLException {
        return execute(statement, () -> super.preparedStatement_executeQuery(chain, statement));
    }

    @Override
    public final int preparedStatement_executeUpdate(FilterChain chain, PreparedStatementProxy statement) throws SQLException {
        return execute(statement, () -> super.preparedStatement_executeUpdate(chain, statement));
    }

    @Override
    public final ResultSetProxy statement_executeQuery(FilterChain chain, StatementProxy statement, String sql) throws SQLException {
        return execute(statement, () -> super.statement_executeQuery(chain, statement, sql));
    }

    @Override
    public final boolean statement_execute(FilterChain chain, StatementProxy statement, String sql) throws SQLException {
        return execute(statement, () -> super.statement_execute(chain, statement, sql));
    }

    @Override
    public final boolean statement_execute(FilterChain chain, StatementProxy statement, String sql, int autoGeneratedKeys) throws SQLException {
        return execute(statement, () -> super.statement_execute(chain, statement, sql, autoGeneratedKeys));
    }

    @Override
    public final boolean statement_execute(FilterChain chain, StatementProxy statement, String sql, int[] columnIndexes) throws SQLException {
        return execute(statement, () -> super.statement_execute(chain, statement, sql, columnIndexes));
    }

    @Override
    public final boolean statement_execute(FilterChain chain, StatementProxy statement, String sql, String[] columnNames) throws SQLException {
        return execute(statement, () -> super.statement_execute(chain, statement, sql, columnNames));
    }

    @Override
    public final int[] statement_executeBatch(FilterChain chain, StatementProxy statement) throws SQLException {
        return execute(statement, () -> super.statement_executeBatch(chain, statement));
    }

    @Override
    public final int statement_executeUpdate(FilterChain chain, StatementProxy statement, String sql) throws SQLException {
        return execute(statement, () -> super.statement_executeUpdate(chain, statement, sql));
    }

    @Override
    public final int statement_executeUpdate(FilterChain chain, StatementProxy statement, String sql, int autoGeneratedKeys) throws SQLException {
        return execute(statement, () -> super.statement_executeUpdate(chain, statement, sql, autoGeneratedKeys));
    }

    @Override
    public final int statement_executeUpdate(FilterChain chain, StatementProxy statement, String sql, int[] columnIndexes) throws SQLException {
        return execute(statement, () -> super.statement_executeUpdate(chain, statement, sql, columnIndexes));
    }

    @Override
    public final int statement_executeUpdate(FilterChain chain, StatementProxy statement, String sql, String[] columnNames) throws SQLException {
        return execute(statement, () -> super.statement_executeUpdate(chain, statement, sql, columnNames));
    }

    protected <T> T execute(StatementProxy statement, ThrowableSupplier<T> callback) throws SQLException {
        String resourceName = buildResourceName(statement);
        T result = null;
        Throwable failure = null;
        try {
            beforeExecute(statement, resourceName);
            result = callback.get();
        } catch (Throwable e) {
            failure = e;
            throw wrap(e, SQLException.class);
        } finally {
            if (logger.isTraceEnabled()) {
                if (result != null) {
                    logger.trace("Execute statement [value : {} , resource name : '{}'] : {}", statement.getLastExecuteSql(), resourceName, result);
                } else if (failure != null) {
                    logger.trace("It's failed to execute Statement[value : {} , resource name : '{}'] : {}", statement.getLastExecuteSql(), resourceName, failure);
                }
            }
            afterExecute(statement, resourceName, result, failure);
        }
        return result;
    }

    /**
     * Execute before call of intercepted method.
     *
     * @param statement    {@link StatementProxy}
     * @param resourceName the resource name
     * @throws Throwable if any error
     */
    protected void beforeExecute(StatementProxy statement, String resourceName) throws Throwable {
    }

    /**
     * Execute after call of intercepted method.
     *
     * @param statement    {@link StatementProxy}
     * @param resourceName the resource name
     * @param result       the result of intercepted method
     * @param failure      the failure of intercepted method
     */
    protected void afterExecute(StatementProxy statement, String resourceName, Object result, Throwable failure) {
    }

    /**
     * Build resource name
     *
     * @param statement {@link StatementProxy}
     * @return non-null
     */
    protected String buildResourceName(StatementProxy statement) {
        String sql = statement.getLastExecuteSql();
        if (Objects.equals(sql, validationSQL)) {
            return sql;
        }
        String dbType = dataSource.getDbType();
        List<SQLStatement> statementList = parseStatements(sql, dbType);
        String resourceName = null;
        if (statementList.size() > 0) {
            SQLStatement sqlStatement = statementList.get(0);
            resourceName = buildResourceName(sqlStatement);
        }
        if (resourceName == null) {
            logger.debug("The JDBC statement can't be recognized, sql : '{}' , dbType : '{}'", sql, dbType);
            resourceName = "UNRECOGNIZED";
        }
        return resourceName;
    }

    private String buildResourceName(SQLStatement sqlStatement) {
        try {
            if (sqlStatement instanceof SQLSelectStatement) {
                return buildResourceName((SQLSelectStatement) sqlStatement);
            } else if (sqlStatement instanceof SQLUpdateStatement) {
                return buildResourceName((SQLUpdateStatement) sqlStatement);
            } else if (sqlStatement instanceof SQLInsertStatement) {
                return buildResourceName((SQLInsertStatement) sqlStatement);
            } else if (sqlStatement instanceof SQLDeleteStatement) {
                return buildResourceName((SQLDeleteStatement) sqlStatement);
            }
        } catch (Throwable e) {
            logger.debug("The JDBC statement can't be parsed, sql : '{}'", sqlStatement, e);
        }
        return null;
    }

    private String buildResourceName(SQLSelectStatement selectStatement) {
        SQLSelect sqlSelect = selectStatement.getSelect();
        SQLSelectQueryBlock sqlSelectQueryBlock = sqlSelect.getFirstQueryBlock();
        if (sqlSelectQueryBlock == null) {
            return null;
        }
        SQLTableSource sqlTableSource = sqlSelectQueryBlock.getFrom();
        return "SELECT " + sqlTableSource.computeAlias();
    }

    private String buildResourceName(SQLUpdateStatement updateStatement) {
        SQLTableSource sqlTableSource = updateStatement.getFrom();
        return "UPDATE " + sqlTableSource.computeAlias();
    }

    private String buildResourceName(SQLInsertStatement insertStatement) {
        SQLExprTableSource sqlTableSource = insertStatement.getTableSource();
        return "INSERT " + sqlTableSource.computeAlias();
    }

    private String buildResourceName(SQLDeleteStatement deleteStatement) {
        SQLTableSource sqlTableSource = deleteStatement.getTableSource();
        return "DELETE " + sqlTableSource.computeAlias();
    }
}
